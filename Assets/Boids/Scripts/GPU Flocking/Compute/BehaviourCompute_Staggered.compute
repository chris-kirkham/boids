// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "../cgincs/behaviourComputeCommon.cginc"

/* Flock buffer offset params */
uint boidsToCompute;
uint boidOffset;
uint framesToComputeEntireFlock;

//returns boid buffer with new positions and velocities
[numthreads(GROUP_SIZE, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint idX = id.x;

    float3 newVel = boids[idX].velocity;
    
    if (idX >= boidOffset && idX < boidOffset + boidsToCompute)
    {
        float dragMultiplier = 1 - friction; //only apply drag if boid behaviour being computed this frame; otherwise boid continues with current velocity
        newVel *= dragMultiplier;
        newVel += (ReactToOtherBoids(idX) + FollowCursor(idX) + MoveIdle(idX) + AffectorInfluence(idX) + ReturnToBounds(idX)) * deltaTime * framesToComputeEntireFlock;
        if (length(newVel) > (maxSpeed * deltaTime)) newVel = normalize(newVel) * maxSpeed * deltaTime;
    }

    float turnAmount = TURNING_SPEED * deltaTime;
    newVel = lerp(boids[idX].velocity, newVel, turnAmount);
    float3 newPos = boids[idX].position + newVel;
    
    boids[idX] = constructBoid(newPos, newVel);
    boidPositions[idX] = float4(newPos, 1);
    boidForwardDirs[idX] = newVel;
}